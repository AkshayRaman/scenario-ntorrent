===TODO===
Make "number of files" a command-line parameter instead of hardcoding it in a header file

Forwarding strategy
afterReceiveInterest - After you get a match, you might have multiple next hops. You pick the best one naively. Keep some score for next hop of the FIB entry. 
afterReceiveData - Use this to calculate Satisfaction rate, delay, use incoming face.
afterReceiveNack - Strategy receives this NACK. Delete garbage from the table

Data structure:
interest-name: Interest timestamp, FIB entry prefix
fib entry prefix: face1:(satisfaction rate, average delay), face2:(satisfaction rate, average delay)...
nack-name: tuple of nacked next hops

Once you receive a NACK, send it downstream based on statistics/FIB

Vector - for delay
From the FIB, you get the face and check the data received/number of interests.. Average delay.

Satisfaction rate, average delay...

Stateful forwarding paper (probe every 200ms)

Probe for -
    to see if you get data. 
    Avoid overloading peers
    
    Weighted average for load

Discover cached data. 
Rule of thumb: 
Once you receive data faster from another interface, use that as a main path and probe the rest.

Refer to https://github.com/named-data/NFD/blob/master/daemon/fw/best-route-strategy2.cpp#L155

Send NACK if you don't have data

Make a change in the consumer to read a random file manifest (instead of 1-n)
Prefix granularity - for simulation (torrent file, manifest, data)


===PROPOSAL===
Routing announcements
Forwarding strategy
Announce torrent, manifest, data
Run experiments
Evaluation

===DONE===
Producer:
torrent prefix
number of files
number of segments per file
(Based on args passed in scenario)

private variables:
    Create torrent file (from torrent-file.cpp)
    Create a vector of manifests (file-manifest.cpp)
    Ignore data packets

One torrent file object
Vector of file manifests
2s delay
Check interest for torrent file/manifest/data packet

Consumer:
Pass torrent prefix
2.2s delay
Send interest for torrent file (with torrent file name) this will reach the producer
After receving the torrent file content, cast it to a torrent file
Use the torrent API file

Try to generate sha256 on the consumer end to avoid hardcoding...
Try adding more consumers/producers ??
Make consumer act as producer

Add report to arxiv

OnInterest method for consumers
Announce prefix to the network after you have a file/prefix..

If you don't have a packet, you send a NACK
Forwarding strategy (deal with this later)

To register prefix (one of these ways)
    RIBManager
        RIBManager (Routing information base) interacts with routing protocol - send command interest to RIBManager and say "Add this prefix"
        Prefix propagation - once you register a prefix to a local NFD, the neighbors will announce it to all neighbors and so on..
        RIBManager adds it to FIB

        Look at helper/fibHelper, helper/strategy-choice-helper
        look at sendCommand, addNextHop, removeNextHop

        How are you going to get access to RIBManager?

        Pointer to rib manager
        Get access to the node ID, get an object, downcast to layer 3 protocol and use this to get the manager
        Look at NFD test cases for some ideas...

    Other way:
        ndn-global-routing-helper.cpp (calculate routes)
        Add origin
        Mimic from global routing helper class if needed
        Just go ahead and try it...

4/10
AddOrigin
CalculateRoutes
CalculateAllPossibleRoutes

(Option 1 is most likely to work)
1 Local FIB, routing helper
2 Just Routing helper


